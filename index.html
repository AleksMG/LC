<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Профессиональный шифратор</title>
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #0f3460;
            --success: #4cc9f0;
            --light: #e94560;
            --dark: #0d0d1a;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.6;
            color: #4cc9f0;
            background: linear-gradient(135deg, var(--dark) 0%, var(--primary) 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.95);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid var(--accent);
        }
        
        header {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%);
            color: white;
            padding: 25px;
            text-align: center;
            border-bottom: 2px solid var(--light);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            color: #4cc9f0;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            padding: 30px;
        }
        
        @media (max-width: 1000px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background: rgba(22, 33, 62, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--accent);
        }
        
        .panel-title {
            font-size: 1.6rem;
            color: #4cc9f0;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--light);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #4cc9f0;
            font-size: 1.1rem;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--accent);
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
            background: rgba(15, 52, 96, 0.3);
            color: white;
            font-family: 'Consolas', monospace;
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: var(--light);
            outline: none;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }
        
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        
        .btn {
            display: inline-block;
            padding: 14px 28px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            margin-right: 12px;
            margin-bottom: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .btn:hover {
            background: var(--light);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .btn-encrypt {
            background: linear-gradient(135deg, #4cc9f0 0%, #3a86ff 100%);
        }
        
        .btn-decrypt {
            background: linear-gradient(135deg, #560bad 0%, #7209b7 100%);
        }
        
        .btn-clear {
            background: linear-gradient(135deg, #f72585 0%, #b5179e 100%);
        }
        
        .btn-generate {
            background: linear-gradient(135deg, #f9c74f 0%, #f9844a 100%);
            color: #1a1a2e;
        }
        
        .result-container {
            margin-top: 20px;
            padding: 20px;
            background: rgba(15, 52, 96, 0.2);
            border-radius: 10px;
            border-left: 4px solid var(--light);
        }
        
        .process-log {
            margin-top: 30px;
            padding: 20px;
            background: rgba(15, 52, 96, 0.2);
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid var(--accent);
        }
        
        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid rgba(76, 201, 240, 0.3);
        }
        
        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 500;
        }
        
        .status-success {
            background: rgba(76, 201, 240, 0.2);
            color: #4cc9f0;
            border-left: 4px solid #4cc9f0;
        }
        
        .status-error {
            background: rgba(233, 69, 96, 0.2);
            color: #e94560;
            border-left: 4px solid #e94560;
        }
        
        .status-warning {
            background: rgba(249, 199, 79, 0.2);
            color: #f9c74f;
            border-left: 4px solid #f9c74f;
        }
        
        .table-container {
            overflow-x: auto;
            margin: 15px 0;
            padding: 15px;
            background: rgba(15, 52, 96, 0.2);
            border-radius: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(22, 33, 62, 0.5);
        }
        
        th, td {
            border: 1px solid var(--accent);
            padding: 12px;
            text-align: center;
            color: white;
        }
        
        th {
            background: var(--accent);
            color: white;
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background: rgba(76, 201, 240, 0.1);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            background: var(--secondary);
            color: white;
            border-top: 2px solid var(--accent);
        }
        
        .password-check {
            display: flex;
            align-items: center;
            margin-top: 5px;
            font-size: 14px;
        }
        
        .password-strength {
            height: 6px;
            border-radius: 3px;
            margin-top: 5px;
            transition: all 0.3s;
            background: var(--accent);
        }
        
        .strength-weak {
            background: linear-gradient(90deg, #e94560 0%, #ac0d2d 100%);
            width: 33%;
        }
        
        .strength-medium {
            background: linear-gradient(90deg, #f9c74f 0%, #f8961e 100%);
            width: 66%;
        }
        
        .strength-strong {
            background: linear-gradient(90deg, #4cc9f0 0%, #3a86ff 100%);
            width: 100%;
        }
        
        .substitution-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .substitution-input {
            flex: 1;
        }
        
        .digit {
            display: inline-block;
            padding: 4px 8px;
            background: rgba(76, 201, 240, 0.3);
            border-radius: 4px;
            font-weight: bold;
            margin: 0 2px;
            border: 1px solid var(--accent);
        }
        
        .crypto-info {
            background: rgba(15, 52, 96, 0.2);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid var(--light);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Профессиональный шифратор</h1>
            <p class="subtitle">Нумерованная таблица замен с зависимостью от пароля</p>
        </header>
        
        <div class="content">
            <div class="panel">
                <h2 class="panel-title">Параметры шифрования</h2>
                
                <div class="form-group">
                    <label for="alphabet">Алфавит (символы без разделителей):</label>
                    <input type="text" id="alphabet" value="АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя .,!?-0123456789"
                           placeholder="Введите символы алфавита">
                </div>
                
                <div class="form-group">
                    <label for="substitutionAlphabet">Символы замены:</label>
                    <div class="substitution-controls">
                        <input type="text" id="substitutionAlphabet" class="substitution-input" 
                               placeholder="Введите символы замены">
                        <button class="btn btn-generate" onclick="generateSubstitutionAlphabet()">Сгенерировать</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="password">Пароль (минимум 8 символов):</label>
                    <input type="password" id="password" placeholder="Введите пароль" value="SecurePass123">
                </div>
                
                <div class="form-group">
                    <label for="mathOperation">Тип математического преобразования:</label>
                    <select id="mathOperation">
                        <option value="affine">Аффинное (a×P + b) mod N</option>
                        <option value="exponential">Экспоненциальное (K^P mod N)</option>
                        <option value="matrix">Матричное преобразование 2×2</option>
                        <option value="nonlinear">Нелінійне перетворення</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="inputText">Исходный текст:</label>
                    <textarea id="inputText" placeholder="Введите текст для шифрования">Привет! Это тестовое сообщение для проверки шифратора. Раз два три четыре пять.</textarea>
                </div>
                
                <button class="btn btn-encrypt" onclick="encrypt()">Зашифровать</button>
                <button class="btn btn-decrypt" onclick="decrypt()">Расшифровать</button>
                <button class="btn btn-clear" onclick="clearAll()">Очистить</button>
            </div>
            
            <div class="panel">
                <h2 class="panel-title">Результаты</h2>
                
                <div class="form-group">
                    <label for="outputText">Результат:</label>
                    <textarea id="outputText" readonly placeholder="Результат появится здесь"></textarea>
                </div>
                
                <div class="result-container">
                    <h3>Статус операции:</h3>
                    <div id="status" class="status status-success">Готов к работе</div>
                </div>
                
                <div class="result-container">
                    <h3>Проверка целостности:</h3>
                    <div id="integrityStatus" class="status">Не проверено</div>
                </div>
            </div>
        </div>
        
        <div class="process-log">
            <h3>Процесс преобразований:</h3>
            <div id="processInfo"></div>
        </div>
        
        <div class="table-container">
            <h3>Нумерованная таблица замен символов:</h3>
            <table id="substitutionTable">
                <thead>
                    <tr>
                        <th>Исходный символ</th>
                        <th>Числовое значение</th>
                        <th>Зашифрованный символ</th>
                        <th>Числовое значение</th>
                        <th>Ключ преобразования</th>
                    </tr>
                </thead>
                <tbody id="substitutionTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="crypto-info">
            <h3>Криптографическая информация:</h3>
            <p><strong>Алгоритм:</strong> Комбинированное преобразование с нумерованной таблицей замен</p>
            <p><strong>Стойкость:</strong> Зависит от пароля и размера алфавита</p>
            <p><strong>Особенности:</strong> Нелинейное преобразование, зависимость от позиции символа, динамическая таблица замен</p>
        </div>
        
        <footer>
            <p>Профессиональный математический шифратор | Нумерованная таблица замен</p>
        </footer>
    </div>

    <script>
        // Глобальные переменные
        let currentCipher = null;
        
        // Генерация символов замены
        function generateSubstitutionAlphabet() {
            const alphabet = document.getElementById('alphabet').value;
            if (!alphabet) {
                showStatus('Сначала введите основной алфавит.', 'error');
                return;
            }
            
            // Создаем массив символов и перемешиваем его
            const chars = alphabet.split('');
            for (let i = chars.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [chars[i], chars[j]] = [chars[j], chars[i]];
            }
            
            const substitutionAlphabet = chars.join('');
            document.getElementById('substitutionAlphabet').value = substitutionAlphabet;
            showStatus('Символы замены сгенерированы.', 'success');
        }
        
        // Показать статус
        function showStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = 'status';
            
            if (type === 'success') {
                statusElement.classList.add('status-success');
            } else if (type === 'error') {
                statusElement.classList.add('status-error');
            } else if (type === 'warning') {
                statusElement.classList.add('status-warning');
            }
        }
        
        // Класс профессионального шифратора
        class ProfessionalCipher {
            constructor(alphabet, substitutionAlphabet, password, operation) {
                this.alphabet = alphabet;
                this.substitutionAlphabet = substitutionAlphabet;
                this.N = alphabet.length;
                this.operation = operation;
                this.password = password;
                
                // Создаем нумерованные маппинги
                this.charToDigit = {};
                this.digitToChar = {};
                this.substitutionToDigit = {};
                this.digitToSubstitution = {};
                
                // Заполняем таблицы нумерации
                for (let i = 0; i < this.N; i++) {
                    this.charToDigit[alphabet[i]] = i;
                    this.digitToChar[i] = alphabet[i];
                    this.substitutionToDigit[substitutionAlphabet[i]] = i;
                    this.digitToSubstitution[i] = substitutionAlphabet[i];
                }
                
                // Генерируем ключи на основе пароля
                this.generateKeys(password);
                
                // Создаем таблицу замен
                this.createSubstitutionTable();
            }
            
            // Генерация ключей на основе пароля
            generateKeys(password) {
                // Создаем хэш пароля для гарантированной зависимости
                let hash = 0;
                for (let i = 0; i < password.length; i++) {
                    hash = ((hash << 5) - hash) + password.charCodeAt(i);
                    hash |= 0;
                }
                
                this.passwordHash = Math.abs(hash);
                
                switch(this.operation) {
                    case 'affine':
                        this.a = (this.passwordHash % (this.N - 1)) + 1;
                        this.b = (this.passwordHash * 13) % this.N;
                        this.invA = this.modInverse(this.a, this.N);
                        break;
                        
                    case 'exponential':
                        this.K = (this.passwordHash % (this.N - 2)) + 2;
                        this.createLogTable();
                        break;
                        
                    case 'matrix':
                        this.generateMatrix();
                        break;
                        
                    case 'nonlinear':
                        this.generateNonLinearParams();
                        break;
                }
            }
            
            // Модульная инверсия
            modInverse(a, mod) {
                a = ((a % mod) + mod) % mod;
                for (let x = 1; x < mod; x++) {
                    if ((a * x) % mod === 1) return x;
                }
                return 1;
            }
            
            // Создание таблицы логарифмов
            createLogTable() {
                this.logTable = new Array(this.N);
                let value = 1;
                for (let exponent = 0; exponent < this.N; exponent++) {
                    this.logTable[value] = exponent;
                    value = (value * this.K) % this.N;
                }
            }
            
            // Генерация матрицы
            generateMatrix() {
                const seed = this.passwordHash;
                this.matrix = [
                    [(seed % (this.N - 1)) + 1, ((seed * 7 + 11) % this.N)],
                    [((seed * 13 + 17) % this.N), ((seed * 19 + 23) % this.N)]
                ];
                
                // Вычисляем детерминант
                const det = (this.matrix[0][0] * this.matrix[1][1] - this.matrix[0][1] * this.matrix[1][0]) % this.N;
                this.invDet = this.modInverse(det, this.N);
                
                // Обратная матрица
                this.invMatrix = [
                    [(this.matrix[1][1] * this.invDet) % this.N, (-this.matrix[0][1] * this.invDet % this.N + this.N) % this.N],
                    [(-this.matrix[1][0] * this.invDet % this.N + this.N) % this.N, (this.matrix[0][0] * this.invDet) % this.N]
                ];
            }
            
            // Генерация нелинейных параметров
            generateNonLinearParams() {
                const seed = this.passwordHash;
                this.nonlinearA = (seed % 7) + 1;
                this.nonlinearB = ((seed * 11) % 5) + 1;
                this.nonlinearC = ((seed * 13) % 3) + 1;
            }
            
            // Нелинейное преобразование
            nonlinearTransform(x, position) {
                // Добавляем зависимость от позиции символа
                const posFactor = (position % 10) + 1;
                return (this.nonlinearA * x * x + this.nonlinearB * x * posFactor + this.nonlinearC * posFactor) % this.N;
            }
            
            // Обратное нелинейное преобразование
            inverseNonlinearTransform(y, position) {
                // Для простоты используем таблицу обратных значений
                const posFactor = (position % 10) + 1;
                
                // Ищем x такой, что nonlinearTransform(x) = y
                for (let x = 0; x < this.N; x++) {
                    const testY = (this.nonlinearA * x * x + this.nonlinearB * x * posFactor + this.nonlinearC * posFactor) % this.N;
                    if (testY === y) return x;
                }
                return 0;
            }
            
            // Создание таблицы замен
            createSubstitutionTable() {
                this.substitutionTable = [];
                
                for (let i = 0; i < this.N; i++) {
                    const P = i;
                    let C;
                    
                    switch(this.operation) {
                        case 'affine':
                            C = (this.a * P + this.b) % this.N;
                            break;
                            
                        case 'exponential':
                            C = this.modExp(this.K, P, this.N);
                            break;
                            
                        case 'matrix':
                            C = (this.matrix[0][0] * P) % this.N;
                            break;
                            
                        case 'nonlinear':
                            C = this.nonlinearTransform(P, 0);
                            break;
                    }
                    
                    // Гарантируем корректный диапазон
                    C = ((C % this.N) + this.N) % this.N;
                    
                    this.substitutionTable.push({
                        originalChar: this.digitToChar[P],
                        originalValue: P,
                        encryptedChar: this.digitToSubstitution[C],
                        encryptedValue: C,
                        key: this.operation === 'affine' ? `a=${this.a}, b=${this.b}` :
                             this.operation === 'exponential' ? `K=${this.K}` :
                             this.operation === 'matrix' ? `M=${this.matrix[0][0]}` :
                             `A=${this.nonlinearA}, B=${this.nonlinearB}, C=${this.nonlinearC}`
                    });
                }
            }
            
            // Модульное возведение в степень
            modExp(base, exponent, mod) {
                if (mod === 1) return 0;
                let result = 1;
                base = base % mod;
                
                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = (result * base) % mod;
                    }
                    exponent = Math.floor(exponent / 2);
                    base = (base * base) % mod;
                }
                
                return result;
            }
            
            // Шифрование текста
            encrypt(text) {
                let result = '';
                let process = '';
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const position = i;
                    
                    // Если символа нет в алфавите, добавляем как есть
                    if (!(char in this.charToDigit)) {
                        result += char;
                        process += `"${char}" → не в алфавите → "${char}"<br>`;
                        continue;
                    }
                    
                    // Получаем числовое значение из нумерованной таблицы
                    const P = this.charToDigit[char];
                    let C;
                    
                    // Применяем преобразование с зависимостью от пароля и позиции
                    switch(this.operation) {
                        case 'affine':
                            C = (this.a * P + this.b + position) % this.N;
                            break;
                            
                        case 'exponential':
                            C = this.modExp(this.K, P + position, this.N);
                            break;
                            
                        case 'matrix':
                            // Для матричного шифрования обрабатываем по два символа
                            if (i + 1 < text.length) {
                                const nextChar = text[i + 1];
                                const P2 = (nextChar in this.charToDigit) ? this.charToDigit[nextChar] : 0;
                                
                                C = (this.matrix[0][0] * P + this.matrix[0][1] * P2 + position) % this.N;
                                const C2 = (this.matrix[1][0] * P + this.matrix[1][1] * P2 + position) % this.N;
                                
                                result += this.digitToSubstitution[C2];
                                process += `"${nextChar}" → <span class="digit">${P2}</span> → [Матричное] = <span class="digit">${C2}</span> → "${this.digitToSubstitution[C2]}"<br>`;
                                i++;
                            } else {
                                C = (this.matrix[0][0] * P + position) % this.N;
                            }
                            break;
                            
                        case 'nonlinear':
                            C = this.nonlinearTransform(P, position);
                            break;
                    }
                    
                    // Гарантируем корректный диапазон
                    C = ((C % this.N) + this.N) % this.N;
                    
                    // Получаем символ замены из нумерованной таблицы
                    const encryptedChar = this.digitToSubstitution[C];
                    result += encryptedChar;
                    
                    // Логирование процесса
                    process += `"${char}" → <span class="digit">${P}</span> → [Преобразование] = <span class="digit">${C}</span> → "${encryptedChar}"<br>`;
                }
                
                document.getElementById('processInfo').innerHTML = process;
                return result;
            }
            
            // Дешифрование текста
            decrypt(text) {
                let result = '';
                let process = '';
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const position = i;
                    
                    // Если символа нет в substitution алфавите
                    if (!(char in this.substitutionToDigit)) {
                        result += char;
                        process += `"${char}" → не в substitution алфавите → "${char}"<br>`;
                        continue;
                    }
                    
                    // Получаем числовое значение из нумерованной таблицы замен
                    const C = this.substitutionToDigit[char];
                    let P;
                    
                    // Обратное преобразование
                    switch(this.operation) {
                        case 'affine':
                            P = (this.invA * (C - this.b - position + this.N)) % this.N;
                            break;
                            
                        case 'exponential':
                            P = (this.logTable[C] - position + this.N) % this.N;
                            break;
                            
                        case 'matrix':
                            // Для матричного дешифрования
                            if (i + 1 < text.length) {
                                const nextChar = text[i + 1];
                                const C2 = (nextChar in this.substitutionToDigit) ? this.substitutionToDigit[nextChar] : 0;
                                
                                P = (this.invMatrix[0][0] * C + this.invMatrix[0][1] * C2 - position + this.N) % this.N;
                                const P2 = (this.invMatrix[1][0] * C + this.invMatrix[1][1] * C2 - position + this.N) % this.N;
                                
                                result += this.digitToChar[P2];
                                process += `"${nextChar}" → <span class="digit">${C2}</span> → [Обратное] = <span class="digit">${P2}</span> → "${this.digitToChar[P2]}"<br>`;
                                i++;
                            } else {
                                P = (this.invMatrix[0][0] * C - position + this.N) % this.N;
                            }
                            break;
                            
                        case 'nonlinear':
                            P = this.inverseNonlinearTransform(C, position);
                            break;
                    }
                    
                    // Гарантируем корректный диапазон
                    P = ((P % this.N) + this.N) % this.N;
                    
                    // Получаем оригинальный символ из нумерованной таблицы
                    const decryptedChar = this.digitToChar[P];
                    result += decryptedChar;
                    
                    // Логирование процесса
                    process += `"${char}" → <span class="digit">${C}</span> → [Обратное] = <span class="digit">${P}</span> → "${decryptedChar}"<br>`;
                }
                
                document.getElementById('processInfo').innerHTML = process;
                return result;
            }
            
            // Отображение таблицы замен
            renderSubstitutionTable() {
                const tableBody = document.getElementById('substitutionTableBody');
                tableBody.innerHTML = '';
                
                for (const item of this.substitutionTable) {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${item.originalChar}</td>
                        <td><span class="digit">${item.originalValue}</span></td>
                        <td>${item.encryptedChar}</td>
                        <td><span class="digit">${item.encryptedValue}</span></td>
                        <td>${item.key}</td>
                    `;
                    tableBody.appendChild(row);
                }
            }
        }
        
        // Шифрование
        function encrypt() {
            try {
                const alphabet = document.getElementById('alphabet').value;
                const substitutionAlphabet = document.getElementById('substitutionAlphabet').value;
                const password = document.getElementById('password').value;
                const operation = document.getElementById('mathOperation').value;
                const inputText = document.getElementById('inputText').value;
                
                if (!alphabet) {
                    showStatus('Введите алфавит для шифрования.', 'error');
                    return;
                }
                
                // Автогенерация substitution алфавита если не задан
                let actualSubstitution = substitutionAlphabet;
                if (!actualSubstitution) {
                    const chars = alphabet.split('');
                    for (let i = chars.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [chars[i], chars[j]] = [chars[j], chars[i]];
                    }
                    actualSubstitution = chars.join('');
                    document.getElementById('substitutionAlphabet').value = actualSubstitution;
                }
                
                // Гарантируем одинаковую длину алфавитов
                if (actualSubstitution.length !== alphabet.length) {
                    if (actualSubstitution.length > alphabet.length) {
                        actualSubstitution = actualSubstitution.substring(0, alphabet.length);
                    } else {
                        actualSubstitution += alphabet.substring(0, alphabet.length - actualSubstitution.length);
                    }
                    document.getElementById('substitutionAlphabet').value = actualSubstitution;
                }
                
                currentCipher = new ProfessionalCipher(alphabet, actualSubstitution, password || 'default', operation);
                const encrypted = currentCipher.encrypt(inputText);
                document.getElementById('outputText').value = encrypted;
                
                // Отображаем таблицу замен
                currentCipher.renderSubstitutionTable();
                
                // Проверяем целостность
                testIntegrity();
                
                showStatus('Текст успешно зашифрован!', 'success');
            } catch (error) {
                showStatus('Ошибка при шифровании: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        // Дешифрование
        function decrypt() {
            try {
                if (!currentCipher) {
                    showStatus('Сначала зашифруйте текст!', 'error');
                    return;
                }
                
                const outputText = document.getElementById('outputText').value;
                const decrypted = currentCipher.decrypt(outputText);
                document.getElementById('outputText').value = decrypted;
                
                showStatus('Текст успешно расшифрован!', 'success');
            } catch (error) {
                showStatus('Ошибка при дешифровании: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        // Проверка целостности
        function testIntegrity() {
            const integrityStatus = document.getElementById('integrityStatus');
            
            if (!currentCipher) {
                integrityStatus.className = 'status status-error';
                integrityStatus.innerHTML = 'Целостность не проверена: шифратор не инициализирован';
                return;
            }
            
            // Тестируем обратимость
            const testText = "Тест123";
            const encrypted = currentCipher.encrypt(testText);
            const decrypted = currentCipher.decrypt(encrypted);
            
            if (testText === decrypted) {
                integrityStatus.className = 'status status-success';
                integrityStatus.innerHTML = 'Целостность проверена: преобразование полностью обратимо';
            } else {
                integrityStatus.className = 'status status-error';
                integrityStatus.innerHTML = 'Целостность нарушена: преобразование не обратимо';
            }
        }
        
        // Очистка
        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            document.getElementById('processInfo').innerHTML = '';
            document.getElementById('substitutionTableBody').innerHTML = '';
            
            const integrityStatus = document.getElementById('integrityStatus');
            integrityStatus.className = 'status';
            integrityStatus.innerHTML = 'Не проверено';
            
            showStatus('Готов к работе', 'success');
        }
        
        // Инициализация при загрузке
        window.onload = function() {
            showStatus('Готов к работе', 'success');
        };
    </script>
</body>
</html>
